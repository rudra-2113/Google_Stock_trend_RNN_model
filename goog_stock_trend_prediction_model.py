# -*- coding: utf-8 -*-
"""GOOG_Stock_Trend Prediction_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DD8MKmm_GrLqNTYnEsbZ0mroT9Ub0X3i

# Importing Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
#Regular Imports
import pandas as pd
import numpy as np
from pandas import Series,DataFrame

#For Visualization
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')
# %matplotlib inline

"""# Importing Dataset(Source=https://in.finance.yahoo.com/quote/GOOG/history)"""

#Getting Stock Data online
from pandas_datareader import DataReader
from datetime import datetime

#For Training Purpose
end= datetime(2020,12,31)                              
start =datetime(end.year-2,end.month,end.day)
GOOG_train=DataReader('GOOG','yahoo',start,end)

#For Testing Purpose
end=datetime(2021,1,31)
start=datetime(2021,1,1)
GOOG_test = DataReader('GOOG','yahoo',start,end)

"""# Basic Analysis Of Stock WRT GOOG_train"""

GOOG_train.head()

GOOG_train.describe()

GOOG_train.info()

GOOG_train['Open'].plot(legend=True,figsize=(10,5),color='blue')
plt.ylabel('Open Stock Price')
plt.title('Open Stock Price Trend')
plt.show()

GOOG_train['Adj Close'].plot(legend=True,figsize=(10,5),color='red')
plt.ylabel('Adj Close Stock Price')
plt.title('Adjusted Close Stock Price Trend')
plt.show()

"""scipy.stats.pearsonr() Calculates a Pearson correlation coefficient and the p-value for testing non-correlation.The Pearson correlation coefficient measures the linear relationship between two datasets.
The correlation coefficient can range in value from âˆ’1 to +1. The larger the absolute value of the coefficient, the stronger the relationship between the variables.
For the Pearson correlation, an absolute value of 1 indicates a perfect linear relationship. A correlation close to 0 indicates no linear relationship between the variables
"""

#Calculating pearsonr
from scipy.stats import pearsonr
p_value,r_value= pearsonr(GOOG_train.Open,GOOG_train['Adj Close'])
print('pearson_r value is ' + str(p_value))

#plotting to visualize correlation
sns.jointplot(x='Open',y='Adj Close',data=GOOG_train,color='darkgreen',kind='scatter')
plt.title('Correlating Open & Adj Close Stock Prices',loc='left')
plt.show()

"""CONCLUSION- 
It can be seen from above three plots that 'Open' & 'Adj Close' stock prices for Google under the given period follow almost similar trend and thus can be seen being somewhat linearly dependant on each other as Pearson correlation coefficient(pearsonr) is ~1.
"""

GOOG_train['Volume'].plot(legend=True,figsize=(15,5),color='black')
plt.title('Volume Traded')
plt.show()

"""
In statistics, a moving average is a calculation used to analyze data points by creating a series of averages of different
subsets of the full data set.In finance, a moving average (MA) is a stock indicator that is commonly used in technical analysis.
The reason for calculating the moving average of a stock is to help smooth out the price data by creating a constantly updated
average price.
"""

moving_avg =[10,20,50]

for i in moving_avg:
    column_name ="MA for %s days(Open)" %(str(i))
    GOOG_train[column_name] = GOOG_train['Open'].rolling(i).mean()

GOOG_train[['Open',
      'MA for 10 days(Open)',
      'MA for 20 days(Open)',
      'MA for 50 days(Open)']].plot(subplots=False,figsize=(12,8),legend=True)
plt.title('Moving Avg On Open Stock Prices')
plt.show()

moving_avg =[10,20,50]

for i in moving_avg:
    column_name ="MA for %s days(Adj Close)" %(str(i))
    GOOG_train[column_name] = GOOG_train['Adj Close'].rolling(i).mean()

GOOG_train[['Adj Close',
      'MA for 10 days(Adj Close)',
      'MA for 20 days(Adj Close)',
      'MA for 50 days(Adj Close)']].plot(subplots=False,figsize=(12,8),legend=True)
plt.title('Moving Avg On Adjusted close Stock Prices')
plt.show()

"""CONCLUSION-The Moving averages over 10,20 & 50 days respectively follow similar trend both for Open as well as Adj Close stock price

NOW,
The adjusted closing price of a stock takes into account dividend payments, splits and other factor which directly influence 
overall return. Comparing the adjusted closing prices for a single stock over a specific duration of time will allow us to 
identify its return.
To calculate daily stock return, it is needed to compare the closing price of the given day in question to the closing price from the previous day. The formula for percentage return begins by dividing the current day's price by the prior day's price. The number 1 is then subtracted from this result before multiplying the resulting figure by 100 to convert it from decimal to percentage format.
"""

GOOG_train['Daily_return']=GOOG_train['Adj Close'].pct_change()
GOOG_train['Daily_return'].plot(legend=True,
                               figsize=(18,12),
                               linestyle='--',
                               marker='D',color='crimson')
plt.title('Daily Return')
plt.ylabel('pct_change')
plt.show()

"""let's get an overall look at the average daily return using a histogram along with kde plot, using seaborn to create a kde plot and pyplot to create histogram on the same figure."""

sns.kdeplot(x=GOOG_train['Daily_return'].dropna(),color='blue')
plt.hist(x=GOOG_train['Daily_return'].dropna(),color='red',bins=100)
plt.title('Avg Daily Return')
plt.show()

"""# Creating RNN with LSTM model to make stock trend (Open) prediction for January 2021

Getting the Open Stock Prices for model
"""

training_set=GOOG_train.iloc[: ,2:3].values

"""Applying Normalization To Data"""

from sklearn.preprocessing import MinMaxScaler
norm_sc = MinMaxScaler(feature_range=(0,1))
scaled_training_set= norm_sc.fit_transform(training_set)

"""Creating 60 Time Step Data Structure"""

X_train=list()
y_train=list()
for i in range (60 ,training_set.shape[0]):
    X_train.append(scaled_training_set[ i-60 :i ,0])
    y_train.append(scaled_training_set[ i,0])
X_train ,y_train =np.array(X_train) ,np.array(y_train)

X_train=np.reshape(X_train ,(X_train.shape[0], X_train.shape[1] , 1))

"""Building The RNN model with 6 LSTM layers along with Dropout regularization"""

from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout

regressor= Sequential()

regressor.add(LSTM(units=50,return_sequences=True , input_shape=(X_train.shape[1],1)))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units=50,return_sequences=True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units=50,return_sequences=True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units=50,return_sequences=True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units=50,return_sequences=True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units=50,return_sequences=False))
regressor.add(Dropout(0.2))

"""Training The Model"""

regressor.add(Dense(units=1))
regressor.compile(optimizer='adam' ,loss='mean_squared_error')
regressor.fit(X_train,y_train, batch_size=32 ,epochs=100)

"""# Making The Prediction for January 2021"""

GOOG_test.head()

GOOG_test.describe()

"""Getting the Open Stock Prices for model"""

Actual_stock_Price= GOOG_test.iloc[:,2:3].values

"""Testing The Model & Making Prediction For Jan-2021."""

dataset_total= pd.concat((GOOG_train['Open'] ,GOOG_test['Open']),axis=0)
inputs=dataset_total[len(dataset_total) -len(GOOG_test) -60 :].values
inputs=inputs.reshape(-1 ,1)
inputs=norm_sc.transform(inputs)
X_test=[]
for i in range (60,inputs.shape[0]):
    X_test.append(inputs[i-60:i ,0])
X_test=np.array(X_test)
X_test=np.reshape(X_test ,(X_test.shape[0] ,X_test.shape[1], 1))
predicted_stock=norm_sc.inverse_transform(regressor.predict(X_test))

"""Concatenating Prediction To The Actual Stock Prices"""

concat_results=np.concatenate((predicted_stock,Actual_stock_Price),axis=1)
comparison_df= DataFrame(concat_results)
comparison_df.columns =['Predicted_stock_Open_Jan-21','Actual_Stock_Open_Jan-21']
comparison_df.index=GOOG_test.index
comparison_df.head()

"""Calculating Error % (|Measured Value-True Value|/True Value)


"""

comparison_df['Error%'] = np.abs((comparison_df['Predicted_stock_Open_Jan-21']-comparison_df['Actual_Stock_Open_Jan-21'])/comparison_df['Actual_Stock_Open_Jan-21'])*100

comparison_df

avg_abs_error=comparison_df['Error%'].mean()
print('The Average Absolute Error% is ' + str(avg_abs_error))

"""Visualizing The Comparison"""

comparison[['Predicted_stock_Open_Jan-21','Actual_Stock_Open_Jan-21']].plot(legend=True,figsize=(10,8),color=['red','blue'])
plt.title('Model Prediction VS Actual Stock')
plt.ylabel('Stock Prices')
plt.show()

"""# Comments-

Stock prices are random in nature.Based on previous datasets it is difficult to predict the relatively exact stock price of next day as these events depend on no.of factors & are absolutely random with no correlation with previous prices,so we can at best predict the trend of the stock price (upward /downward trend) that I tried to predict here.
"""